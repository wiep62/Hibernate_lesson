1. Нужно создать файл с настройками хибернета
2. в МАЙН настройить SessionFactory - 1 раз на всё приложение (он используется 1 раз он очень мноог весит и долго запускается. НЕЛЬЗЯ УКАЗЫВАТЬ ПОЛНЫЙ ПУТЬ)
3.  Открываем сессию (любое взаим. с БД происходит через сессию - открыл а потом закрыл)
Нельзя сессию держать открытой
4. Нужно создать сущность (User)
- при созд-ии сущности нужно указать ХИБЕНЕТУ что наш класс явл. сущностью (ЕНТИТИ) и указать таблицу ЮЗЕРС (можно и н указывать но тогда хибернейт будет использовать таблицу ЮЗЕР )
- создать геттеры и сеттеры и пустой конструктор (в ГИБЕРНЕТЕ сначала зап-ся сеттеры а потом пустой конструктор)
5. Созд. импорт СКЛ:
PRIMARY KEY - первичный ключ
id bigserial (инкрементируемый тип при сохранении увеличивается) - постгресовский тип данных как лонг и т.д.
6. достаем ЮЗЕРА:
     User user = session.get(User.class, 1);
7. создаем нового юзера:
User user = new User("Jon");
session.save(user);
id мы не указываем т.к. у нас по умолчанию в БД итерация
//получаем пользователя:
       session.getTransaction().begin();

        // 1. User user = session.get(User.class, 3);
    User user = new User("Jon");
    session.save(user);
         session.getTransaction().commit();
         session.close();

         //получаем пользователя
     session.getTransaction().begin();
               User user = session.get(User.class, 3L);
               System.out.println(user);
               session.getTransaction().commit();
               session.close();

  8. Персистенс контекст (типо коробочка):
  когда обр-ся к польз-лю 1 или 2 то он сохр-ся в "коробочке"
нам передается ссылка на этот объект который нах-сЯ в персистенс контекст
- ОБЪЕКТЫ С КОТОРЫМИ МЫ РАБОТАЕМ - КОПИИ ОРИГИНАЛА, кот. находится в персистенс контекст
-после изм-ния обект - хибернейт сравнивает, если не одинаковые то объект изменится

СЕШН ФЭКТОРИ - тяжелый объект:
-хибернет подг-ет все материалы для объекта и хранит их в эешн фэктори
-перед запуском приложения он подг. такие запросы под все объекты
Вывелся объект, не выполняли СЕЙВ но имя поменялось:
(когда мы меняем имя, выполняя коммит-транзакции - хибернейт автоматически подготавл. апдейт скрипт, который это имя меняет )
Для того чтобы работать с объектом (менять его), и чтобы он не менялся в БД нужно, нам необходимо отвязать объект
отконтекста постоянства ПЕРСИСТЕНСКОНТЕКСТА.
СОСТОЯНИЕ СУЩНОСТЕЙ:
-transient (не находится под упр-ем персистент контекста)
-managed (persistent) (когда достаем объекты из БД )
-detached (мы отвязали объект от постоянства)
-removed (есть перс.контексте, после выполнения уд-ся из БД)

   session.getTransaction().begin();
            User userOne = session.get(User.class, 3L);
            userOne.setName("Frank");
            session.getTransaction().commit();
            session.close();

            session = sessionFactory.getCurrentSession();
            session.getTransaction().begin();

            User user = session.get(User.class, 3L);

            session.save(user);
            session.getTransaction().commit();
            System.out.println(user);

РЕФЛЕКСИЯ !!!

 СВЯЗИ:
 1 к 1 (соединение с помощью внешнего ключа):
 имеется емплеес и он связан с ЕМПЛЕЕС_ДЕТАЛИС, они принадлежать только друнг другу

 jdbc место гибернейта (нужно много настроек)!
 для каждого работника свой АДРЕСС() и т.д.
- созд-ем сущность Employee в БД ее создать, потом в Employee указать первичный ключ @Table(name = "employees")
указываем 1-ый ключ :
@OneToOne
    @JoinColumn(name = "details_id") - есть в классе ЕМПАЙ
    private EmployeeDetails details;
не обяз-но указывать в employees_details того работника к которому мы мапимся , мы можем просто примапиться в поле ДЕТАЙЛС
, которые есть уже у нас в классе ЕМПЛАЙ
    ********************
если поменяем details на другое то     private EmployeeDetails details; //todo мапимся к полю
в классе ЕМПЛОЕДЕТАИЛЗ нужно поменять  @OneToOne(mappedBy = "details")
МЫ ПРИВЯЗЫВАЕМСЯ КОНКРЕТНО К ПОЛЮ.
мы ссылаемся 1 к одному и кроме аннотаций больше ничего не нужно)

мы не обращались к емплайДетайлз. Взяли работника , хибирнейт увидел свЯзь с аннотацией ЕМПЛАЙДЕТАИЛЗ (1 к 1)
и подтянул работника в момент когда мы его достали (вывел емаил, город и т.д.)
    session.getTransaction().begin();
            Employee userOne = session.get(Employee.class, 1L);
            System.out.println(userOne.getDetails());
            session.getTransaction().commit();
            session.close();

***************************************************************

-- m21  ---------------
к 1-му объекту может принадл, неск других. (УНИВЕР - ЕМУ ПРИНАДЛЕЖАТ СТУДЕНТЫ, ПРЕПОДЫ и т.д.)
у студента 1 универ(многие к 1), а у универа много студентов(1 ко многим)
ЭТО МЫ УЗНАЕМ У СТУДЕНТОВ!!! (СОЗДАЕМ ТАБЛ СО СТУДЕНТАМИ)
СОЗДАДИМ АЙДИШНИК, ДАДИМ ИМЯ И СДЕЛАЕМ ССЫЛКУ НА АЙДИ УНИВЕРСИТЕТА.(ТАК ПОЙМЕМ КАКИЕ СТУДЕНТЫ В КАКОМ УНИВЕРЕ УЧАТСЯ)
--DROP TABLE IF EXISTS students CASCADE;
--CREATE TABLE students (id bigserial PRIMARY KEY, name VARCHAR(255), university_id bigint REFERENCES universities (id));
--INSERT INTO students (name, university_id) VALUES('Alexander', 1),('Bob', 2),('John', 1);

создадим табл. Универ:
-- m21
DROP TABLE IF EXISTS universities CASCADE;
CREATE TABLE universities (id bigserial PRIMARY KEY, title VARCHAR(255));
INSERT INTO universities (title) VALUES('DSTU'),('NPU');
*** создадим ID и NAME. по кмолчанию УНИВЕР НЕ ЗНАЕТ КАКИЕ У НЕГО СТУДЕНТЫ
UNIVERSITY
    @OneToMany(mappedBy = "university")  //СВЯЗЬ С ТАБЛ СТУДЕНТЫ
    private List<Student> students; //TODO СПИСОК СТУДЕНТОВ. если зайдем в студенты то увидим поля студентов, присоединяем ДЖОЙН М к 1 . ЛИСТ УНИВЕРСИТЕТ ВСЕГДА БУДЕТ ОДИН
//todo если достанем 1-го студента то у него достанем только 1 универ к которому он принадлежит. Но если достанем универ, мы достанем всех студентов которые там учатся

main:
    session.getTransaction().begin();
            University university = session.get(University.class, 1L);
            System.out.println(university.getStudents());
            session.getTransaction().commit();
            session.close();

            -***********************************************

******************
ПЕРСИСТЕНС КОНТЕКСТ И 12М СВЯЗЬ М2М:
ДОСТАНЕМ ОБЪЕКТ ВЫВОДИТЬ ЕГО НИКУДА НЕ БУДЕМ , ЗАКРОЕМ ТРАНЗАКЦИЮ, СЕССИЮ:
            session.getTransaction().begin();
            University university = session.get(University.class, 1L); //ОБЪЕКТ ЕСТЬ В ПАМЯТИ, ССЫЛКА НА НЕГО НЕ ПРОПОДАЛА
            session.getTransaction().commit();
            session.close();

            System.out.println(university.getStudents()); //TODO СТУДЕНТОВ ДОСТАТЬ НЕ ПОЛУЧИЛОСЬ,
            System.out.println(university.getTitle()); //TODO СПИСОК УНИВЕРОВ ВЫВОДИТСЯ
//TODO ХИБИРНЕТ ДОСТОЕТ ОБЪЕКТ УНИВЕР И ДОСТАЕТ У НЕГО ВСЕХ СТУДЕНТОВ
ЕСЛИБЫ ХИБЕРНЕТ РАБОТАЛ КАК СО СВЯЗЬЮ 12М, ТО МВ ДОСТ-ЕМ УНИВЕР И ВСЕХ СТУДЕНТОВ,
У КАЖДОГО СТУДЕНТА СВЯЗЬ 12М НА ВСЕ ПРЕДМЕТЫ КОТОРЫМИ СТУДЕНТ ЗАНИМАЕТСЯ , А У КАЖДОГО ПРЕДМЕТА СВЯЗЬ НА ПРЕПОДАВАТЕЛЕЙ КОТОРЫЕ ВЕДУТ ИХ
//TODO ПОЛУЧАЕТСЯ ОГРАМАДНЕЙШЕЕ ДЕРЕВО (ЦЕПОЧКА) ПОЛУЧИМ Б ПРОБЛЕМЫ , ПРИ 121 КОГДАБ МЫ ДОСТАВАЛИ УНИВЕР (УЗНАТЬ ЕГО ИМЯ), ТО ПОМИМО УНИВЕРА ДОСТАЛИ БЫ ВСЮ ЦЕПОЧКУ И ЗАБИЛИ БЫ ПАМЯТЬ.

**********ЕСТЬ ПАРАМЕТР ФЕЧТАЙП ***********
ПО УМОЛЧ.12М И М2М ФЕЧТАЙП УСТАНОВЛЕН НА ЛЕЙЗИ -> МЫ МОЖЕМ ДОСТАВАТЬ ОБЪЕКТЫ ТОЛЬКО ЕСЛИ МЫ ИХ ПОПРОСИМ
//TODO ТОЛЬКО КОГДА СЕССИЯ ТРАНЗАКЦИЯ БУДУТ ОТКРЫТЫ!!!
А ЕСЛИ ЗАКРЫТА , ТО МЫ УЖЕ СТУДЕНТОВ НЕ ПОЛУЧИМ
** ХИБЕРНЕТ ДОСТАЕТ ИСКЛЮЧИТЕЛЬНО ОБЪЕКТ УНИВЕРСИТЕТ И ВСЕ ОБЫЧНЫЕ ПОЛЯ КОТОРЫЕ В НЕМ ЕСТЬ,
НО ЕСЛИ ЕСТЬ 12М ИЛИ М2М СВЯЗИ ПОКА МЫ НЕ ЗАХОТИМ СПИСОК СТУДЕНТОВ ДОСТАТЬ, ЯВНО НЕ СКАЖЕМ ХИБЕРНЕЙТУ ОН ДОСТАВАТЬ НЕ БУДЕТ
--- МЫ ДЕЛАЕМ ЗАПРООС НА УНИВЕР, НО КРОМЕ УНИВЕРА НИЧЕГО НЕ ДОСТАНЕМ

ДОСТАНЕМ СТУДЕНТОВ В РАМКАХ ТРАНЗАКЦИИ:
1. ОТКР. СЕССИЯ - ДОСТАЕМ УНИВЕР - ГОВАРИМ ХИБЕРНЕЙТУ ДОСТАТЬ НАЗВ. УНИВЕРОВ - ПРОСИМ ДОСТАТЬ СТУДЕНТОВ ПОКА СЕССИЯ ОТКРЫТА
main:
//ДОСТАЕМ СТУДИКОВ:
            session.getTransaction().begin();
            University university = session.get(University.class, 1L); //ОБЪЕКТ ЕСТЬ В ПАМЯТИ, ССЫЛКА НА НЕГО НЕ ПРОПОДАЛА
            System.out.println(university.getStudents());
            System.out.println(university.getTitle());

            session.getTransaction().commit();
            session.close();

            //todo доставать студентов только в рамках транзакции, а когда вытащим то можем работать

            некоторые поля которые создаем их можем делать техническими:
            в университи :
            создаем поле тест оно находится в поле сущности, но его не д.б. видно в БД
                @Transient помогает скрыть поле , при запросах его не будет видно
                private String test;
//todo нужно обязательно ставить ОБЕ аннотации связи для понятности


****** М2М :
 есть ЮЗЕР есть ПРОДУКТ:
 Юзер с №1 покупает продукт №2,
 Юзер с №1 покупает продукт №3,
 Юзер с №2 покупает продукт №1
 Юзер с №2 покупает продукт №2
 Юзер с №2 покупает продукт №3

 тут не подходят ОБЫЧНЫЕ СВЯЗИ!!!
1 юзер и 2 юзер купили продукт №2
1 юзер и 2 юзер купили продукт №3
2 юзер купил продукт №2

//todo много польз могут ссылать на много продуктов!!!
//todo продукт не принадлежит конкретному юзеру!
//todo есть отдельная табл с продуктами, пользователями и всеми полями,  и отдельная таблица в которой лежит запись о пользователях с их продуктами

******** НА ПРИМЕРЕЬ БД ИЗ КНИГ:
1. СОЗДАЕМ КНИГИ
2. СОЗДАЕМ ЧИТАТЕЛЕЙ (У НИХ НЕТ КЛЮЧЕЙ, САМИ ПО СЕБЕ)
//TODO ВМЕСТО РЕФЕРЕНСОВ И ВНЕШНИХ КЛЮЧЕЙ У НАС ВЫСТУПАЕТ ТАБЛИЦА БУКС_РИДЕРС
3.БУКС_РИДЕРС - создаем таблицу с бук_ид, ридер_ид они ссылаются на свои таблицы (книги и читателей)
добавляем в ячейки кто что взял и прочитатл.

//todo мы присваем разные ссылки объектам, потом когда ХН будет выполнять коммит , выпадет ЭКСЕПШН о том,
что есть проблемы и мы не понимаем какое из значений нам сделать правильным, будет ошибка!!!
*** МНОГО ОБЪЕКТОВ с 1-им ИД ССЫЛ-СЯ на 1 и тотже персистенс или меняем один, то меняются все? -  у нас лежит ссылка и когда меняем объект все менятся не должны (как объекты в ДЖАВА)

БУК:
    @ManyToMany
    @JoinTable( указываем имя табл. которая выступает посредником для связи М2М(букс_ридерс) и присоединяем к колонке:
    1.joinColumns - book_id это та колонка которая отвечает за сущность колонки БУК и inverseJoinColumns (то на что будем ссылаться) reader_id
    если посмотреть на reader_id то связи будут вверх ногами (если посмотреть в РИДЕР)
            name = "books_readers",
            joinColumns = @JoinColumn(name = "book_id"),
            inverseJoinColumns = @JoinColumn(name = "reader_id")
    )

    *****************

ридер с id 1 прочитал много книг:

     session.getTransaction().begin();
            Reader reader = session.get(Reader.class, 1L); //ОБЪЕКТ ЕСТЬ В ПАМЯТИ, ССЫЛКА НА НЕГО НЕ ПРОПОДАЛА
            System.out.println(reader.getBooks()); //сколько книг прочитал читатель
            session.getTransaction().commit();
            session.close();
у анотации М2М есть ФЕЧТАЙП.ЛЕЙЗИ, ЕГЕР лучше не ставить

*****************КЭШ*******************
персистенс контекст выдает нам ссылки на объект с которыми мы работем.
он имеет пост связ с БД и выдает нам ссылки
1. мы достали ридера и хотим его достать нес-ко раз (с 1-им №)
в БД он выполнился только 1 раз
хибернет идентифицирует наш объект строго по ID, можем у объекта поменять все поля, но он всегда буджет привязан к ИД
если мы достаем объект с 1-им ИД, то мы впринципе получим тот объект который лежит в ХИБЕРНЕТе, он ничего с ним делать не будет


//todo МАППЕТБАЙ - указание на поле класса/ ДЛЯ СВЯЗЫВАЮЩЕЙ ТАБЛИЦЫ СУЩНОСТЬ СОЗДАВАТЬ НЕ НУЖНО
